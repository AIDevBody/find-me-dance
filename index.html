<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Swing Calendar Feed Builder</title>
  <!--
    This page lets you compose a tag-based calendar feed for the Swing
    community. It mirrors the look and feel of the original Swing Tag
    Builder but instead of outputting a simple list of hashtags, it
    generates a ready‚Äëto‚Äëuse iCalendar (ICS) feed URL. The feed URL
    points at your deployed Google Apps Script (see the README or your
    deployment settings) and includes query parameters for every tag
    you select. Multiple selections within a single category are joined
    with commas. Subscribe to the resulting link in your favourite
    calendar client (Google Calendar, Apple Calendar, Outlook, etc.) to
    automatically receive events that match the selected tags.
  -->
  <style>
    :root {
      --gap: 12px;
      --pad: 14px;
      --radius: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    /* Constrain the width of the content on large screens */
    .container {
      max-width: 960px;
      margin-left: auto;
      margin-right: auto;
    }
    body {
      margin: 0;
      padding: 20px;
      background: #0b0f16;
      color: #eaf0ff;
    }
    a {
      color: #9bcbff;
    }
    header {
      margin-bottom: 22px;
    }
    .card {
      background: #121827;
      border: 1px solid #1f2a44;
      border-radius: var(--radius);
      padding: var(--pad);
      margin-bottom: var(--gap);
    }
    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: var(--gap);
    }
    .group {
      border: 1px solid #233455;
      border-radius: var(--radius);
      padding: var(--pad);
    }
    .group h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      font-weight: 600;
      color: #bcd1ff;
    }
    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    /* Push the clear‚Äëall button to the far right of the controls */
    #clearAll {
      margin-left: auto;
    }
    button,
    select {
      background: #1a2540;
      color: #eaf0ff;
      border: 1px solid #2a3f66;
      border-radius: 10px;
      padding: 8px 10px;
    }

    /* Highlight the copy button */
    #copyLink {
      background: #3c548a;
      border-color: #4c6db5;
      color: #ffffff;
    }
    #copyLink:hover {
      background: #4c6db5;
    }
    input[type="text"] {
      width: 100%;
      background: #0e1527;
      color: #eaf0ff;
      border: 1px solid #2a3f66;
      border-radius: 10px;
      padding: 10px;
    }
    .muted {
      color: #9fb3d9;
    }
    .footer {
      margin-top: 20px;
      font-size: 12px;
    }
    details {
      margin-top: 8px;
    }
    summary {
      cursor: pointer;
    }

    /* Align the title and language selector on one line */
    .title-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: var(--gap);
    }
    /* Container for the language selector */
    .lang-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    /* Inline how-to text with button */
    .howto {
      margin-top: var(--gap);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }
    .howto a {
      background: #1a2540;
      color: #eaf0ff;
      border: 1px solid #2a3f66;
      border-radius: 10px;
      padding: 6px 10px;
      text-decoration: none;
    }
    /* Warning text inside groups when all options selected */
    .warning {
      font-size: 12px;
      color: #e5b867;
      margin-top: 6px;
    }
    /* Float the copy button on small screens so it stays accessible */
    @media (max-width: 600px) {
      #copyLink {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        /* Increase the size and prominence of the floating copy button on small devices */
        padding: 12px 16px;
        font-size: 16px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
      }
    }
  </style>
</head>
<body>
  <div class="container">
  <header>
    <div class="title-bar">
      <!-- Title text will be localised via JavaScript -->
      <h1 id="title">üé∑ Swing Calendar Feed Builder</h1>
      <!-- Language selector moved into header for better positioning -->
      <div class="lang-container">
        <label id="langLabel"></label>
        <select id="lang"></select>
      </div>
    </div>
    <!-- Introductory paragraph will be localised via JavaScript -->
    <p id="intro" class="muted">
      Select the tags that describe your interests and we'll build a
      personalised calendar feed. Subscribe to the generated URL in
      your calendar client to stay up to date with events that match
      your selections.
    </p>
    <!-- Inline how‚Äëto text with link to the full instructions page. Visible at all times. -->
    <div id="howToInline" class="howto muted">
      <span id="howToText">Copy the Feed URL above and paste it into your calendar application‚Äôs ‚Äúsubscribe to calendar‚Äù dialog.</span>
      <!-- Do not open the instructions in a new window; users stay in the same tab -->
      <a id="howToButton" href="pages/instructions.html">Instructions</a>
    </div>
  </header>

  <section class="card">
    <div class="controls">
      <button id="copyLink">Copy link</button>
      <button id="clearAll">Clear all</button>
    </div>
    <details>
      <summary>Feed URL</summary>
      <div style="margin-top:8px;">
        <input id="feedUrl" type="text" readonly />
      </div>
    </details>
  </section>

  <section id="groups" class="row"></section>

  <div class="footer muted">
    <p>
      This page uses a locally stored list of tags to build the feed URL. It
      does not contact any external servers until you subscribe to the URL.
    </p>
  </div>
  </div> <!-- end container -->

  <script>
  // Base URL of your deployed Google Apps Script Web App (see user instructions)
  const BASE_URL = 'https://script.google.com/macros/s/AKfycbwLZ7yudmpkonocViR2Ai1TRiuW9Q0ho2DsNHABA88sUVXazLOg1rTrnFCNTcknCwjEtQ/exec';

  // Simple global error handler to log uncaught errors to the console.  This
  // remains quiet in the UI but aids debugging during development.
  window.addEventListener('error', (e) => {
    console.error('Uncaught error:', e.message);
  });

  // Localised UI strings for English and German.  These strings control
  // the visible text on the page (titles, buttons, labels, etc.).  If you
  // extend this page to support additional languages, add entries here.
  const uiStrings = {
    en: {
      title: 'üé∑ Swing Calendar Feed Builder',
      intro: 'Select the tags that describe your interests and we\'ll build a personalised calendar feed. Subscribe to the generated URL in your calendar client to stay up to date with events that match your selections.',
      language: 'Language:',
      copyLink: 'Copy calendar URL',
      copySuccess: 'Copied!',
      clearAll: 'Clear all tags',
      feedUrlSummary: 'Feed URL',
      howToSummary: 'How to subscribe',
      howToText: 'Copy the Feed URL above and paste it into your calendar application\'s ‚Äúsubscribe to calendar‚Äù or ‚Äúadd by URL‚Äù dialog. Most calendar clients support the iCalendar format.',
      inlineHowTo: 'Copy the feed URL above and paste it into your calendar application‚Äôs ‚Äúsubscribe to calendar‚Äù dialog.',
      instructionsLabel: 'Instructions',
      footer: 'This page uses a locally stored list of tags to build the feed URL. It does not contact any external servers until you subscribe to the URL.',
      all: 'All',
      none: 'None',
      allSelectedWarning: 'All tags selected: events without this type won‚Äôt appear. Select none to see all.'
    },
    de: {
      title: 'üé∑ Swing Kalender-Feed-Generator',
      intro: 'W√§hle die Tags aus, die deine Interessen beschreiben, und wir erstellen einen personalisierten Kalender-Feed. Abonniere die erzeugte URL in deiner Kalender-App, um √ºber passende Veranstaltungen auf dem Laufenden zu bleiben.',
      language: 'Sprache:',
      copyLink: 'Kalender‚ÄëURL kopieren',
      copySuccess: 'Kopiert!',
      clearAll: 'Alle Tags l√∂schen',
      feedUrlSummary: 'Feed-URL',
      howToSummary: 'So abonnierst du',
      howToText: 'Kopiere die oben angezeigte Feed-URL und f√ºge sie in das Dialogfeld ‚ÄûPer URL abonnieren‚Äú deiner Kalender‚ÄëApp ein. Die meisten Kalender unterst√ºtzen das iCalendar‚ÄëFormat.',
      inlineHowTo: 'Kopiere die oben angezeigte Feed-URL und f√ºge sie in das Dialogfeld ‚ÄûKalender abonnieren‚Äú deiner Kalender-App ein.',
      instructionsLabel: 'Anleitung',
      footer: 'Diese Seite nutzt eine lokal gespeicherte Liste von Tags, um die Feed-URL zu erstellen. Es werden keine externen Server kontaktiert, bis du die URL abonnierst.',
      all: 'Alle',
      none: 'Keine',
      allSelectedWarning: 'Alle ausgew√§hlt: Ereignisse ohne diese Kategorie werden nicht angezeigt. W√§hle keine aus, um alle zu sehen.'
    }
  };

  // Holds translated display names for each tag type (group labels).  This
  // mapping is populated asynchronously from tags/ui/tags_ui.csv on page load.
  let typeDisplay = {};

  // Fetch the tag UI CSV and build the typeDisplay map.  The CSV is expected
  // to have columns: tag_type, ui_type, display_en, display_de.  Any
  // additional languages can also be supported by adding more display_xx
  // columns.  Returns a promise that resolves when parsing is complete.
  async function loadTypeDisplay() {
    // Fetch the UI definitions for tag types.  This CSV lives under
    // resources/tags/ui/tags_ui.csv after we moved the tag folder into
    // the resources directory.  It contains columns: tag_type,
    // ui_type, display_en, display_de, etc.  We detect all
    // languages by looking for columns matching display_*.  The
    // resulting map is stored in the global typeDisplay object.
    try {
      // Fetch using a relative path from the resources directory.
      const res = await fetch('resources/tags/ui/tags_ui.csv', { cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to load tag UI definitions');
      const text = await res.text();
      const lines = text.trim().split(/\r?\n/);
      if (lines.length === 0) return;
      const header = lines[0].split(',');
      const idxType = header.indexOf('tag_type');
      const langCols = {};
      header.forEach((h, i) => {
        const m = h.match(/^display_(.+)$/);
        if (m) langCols[m[1]] = i;
      });
      const map = {};
      for (let i = 1; i < lines.length; i++) {
        const parts = lines[i].split(',');
        const type = parts[idxType];
        if (!type) continue;
        if (!map[type]) map[type] = {};
        for (const lang in langCols) {
          map[type][lang] = parts[langCols[lang]] || type;
        }
      }
      typeDisplay = map;
    } catch (err) {
      console.error(err);
      // fallback: leave typeDisplay empty if the file can't be loaded
    }
  }

  // Load all tag definitions from the CSV files under
  // resources/tags/all.  We determine which files to load based on the
  // tag types listed in the UI definitions (typeDisplay) or from the
  // names of files in that directory.  Each CSV must have columns
  // tag_type, tag, display_XX (for each language), and is-active
  // indicating whether the tag should be presented to the user.  Any
  // number of languages is supported: language codes are derived
  // automatically from the header names.  The resulting tags are
  // stored in the global tagsByType object keyed by tag_type.  The
  // global languages array is also updated to include all languages
  // encountered across the CSVs.
  async function loadTagsData() {
    // Determine candidate tag types from the UI definition.  If
    // typeDisplay is empty (for example if the UI CSV failed to load),
    // fall back to a hardcoded list of tag names that match the files
    // provided by the update_tags.sh script.
    const defaultTypes = [
      'location', 'dance_type', 'event_type', 'level', 'role',
      'music_speed', 'music_source', 'language', 'venue_type',
      'registration', 'price_type', 'age_policy', 'footwear'
    ];
    const types = Object.keys(typeDisplay);
    const toLoad = types.length > 0 ? types : defaultTypes;
    // Set to collect all languages discovered across all files
    const langSet = new Set(languages);
    // For each tag type, fetch and parse its CSV file
    for (const type of toLoad) {
      try {
        // Build the relative path to the CSV file.  Do not use absolute
        // file URLs as some environments may block them.
        const res = await fetch(`resources/tags/all/${type}.csv`, { cache: 'no-store' });
        if (!res.ok) {
          console.warn(`Could not load tags for type ${type}`);
          continue;
        }
        const csvText = await res.text();
        const lines = csvText.trim().split(/\r?\n/);
        if (lines.length === 0) continue;
        const header = lines[0].split(',');
        const idxTag = header.indexOf('tag');
        const idxActive = header.findIndex(h => h.toLowerCase() === 'is-active');
        // Detect language columns in the form display_xx
        const displayCols = {};
        header.forEach((h, i) => {
          const m = h.match(/^display_(.+)$/);
          if (m) {
            const code = m[1];
            displayCols[code] = i;
            langSet.add(code);
          }
        });
        // Prepare array of tag objects for this type
        const items = [];
        for (let i = 1; i < lines.length; i++) {
          // If there are extra commas inside quoted fields this split
          // might misbehave; but our spreadsheets produce simple CSVs.
          const parts = lines[i].split(',');
          const tagVal = parts[idxTag];
          // Skip rows without a tag value
          if (!tagVal) continue;
          // Only include active tags
          const isActive = idxActive >= 0 ? (parts[idxActive] || '').toLowerCase() === 'true' : true;
          if (!isActive) continue;
          const obj = { tag: tagVal };
          for (const code in displayCols) {
            obj[`display_${code}`] = parts[displayCols[code]] || tagVal;
          }
          items.push(obj);
        }
        // Store items for this type
        tagsByType[type] = items;
      } catch (err) {
        console.warn(`Error loading tag CSV for ${type}:`, err);
      }
    }
    // Update the global languages array based on the discovered set
    languages = Array.from(langSet);
  }

  // Update all static texts on the page based on the current language
  function updateStaticText() {
    const langSel = document.getElementById('lang');
    const lang = langSel.value || 'en';
    const strings = uiStrings[lang] || uiStrings.en;
    // Header title and intro
    const h1 = document.querySelector('header h1');
    if (h1) h1.textContent = strings.title;
    const introP = document.querySelector('header p');
    if (introP) introP.textContent = strings.intro;
    // Language label in the header
    const langLabel = document.getElementById('langLabel');
    if (langLabel) {
      // Clear and rebuild the label text (select element remains separate)
      langLabel.textContent = strings.language + ' ';
    }
    // Buttons
    const copyBtn = document.getElementById('copyLink');
    if (copyBtn) copyBtn.textContent = strings.copyLink;
    const clearBtn = document.getElementById('clearAll');
    if (clearBtn) clearBtn.textContent = strings.clearAll;
    // Details summary for the Feed URL section
    const details = document.querySelectorAll('details');
    if (details.length > 0) {
      const sum1 = details[0].querySelector('summary');
      if (sum1) sum1.textContent = strings.feedUrlSummary;
    }
    // Footer text
    const footerP = document.querySelector('.footer p');
    if (footerP) footerP.textContent = strings.footer;

    // Inline how-to text and instructions button
    const howToSpan = document.getElementById('howToText');
    if (howToSpan) howToSpan.textContent = strings.inlineHowTo;
    const howToBtn = document.getElementById('howToButton');
    if (howToBtn) howToBtn.textContent = strings.instructionsLabel;
  }

  // Every category is rendered as a set of checkboxes. The original
  // Swing Tag Builder supported different UI widgets (dropdowns,
  // radios, etc.), but for simplicity and flexibility we ignore
  // those definitions here. This means visitors can select multiple
  // options per category. See renderGroup() for details.

  // Tags grouped by type will be populated by reading CSV files from
  // resources/tags/all on page load.  Each entry in this object
  // contains an array of tag definitions for that type.  See
  // loadTagsData() below for implementation.
  const tagsByType = {};

  // Note: We intentionally omit normalising UI types since every group
  // is rendered as a multi‚Äëselect checkbox list. See renderGroup().

  // State holds the currently selected tags for each type. Values are sets
  // to easily add/remove selections.
  const state = {};

  // List of available languages will be determined after loading the
  // tag CSVs.  Initialise with sensible defaults; loadTagsData()
  // updates this array once tags have been parsed.
  let languages = ['en', 'de'];

  // Populate the language selector and wire up change handler.  When the
  // selected language changes we update static text and re-render the groups.
  function initLanguages() {
    const sel = document.getElementById('lang');
    // Clear any existing options
    sel.innerHTML = '';
    languages.forEach(lang => {
      const opt = document.createElement('option');
      opt.value = lang;
      opt.textContent = lang;
      sel.appendChild(opt);
    });
    // Try to default to browser language if available
    const browserLang = (navigator.language || 'en').slice(0, 2);
    if (languages.includes(browserLang)) sel.value = browserLang;
    else if (languages.includes('en')) sel.value = 'en';
    sel.addEventListener('change', () => {
      updateStaticText();
      rerenderAll();
    });
  }

  // Build the UI groups based on tagsByType and ui definitions. This is
  // called whenever the language changes or the UI needs to be
  // refreshed. It clears any existing groups and reconstructs the
  // controls.
  function rerenderAll() {
    const container = document.getElementById('groups');
    container.innerHTML = '';
    for (const type of Object.keys(tagsByType).sort()) {
      renderGroup(type);
    }
    updateFeedUrl();
  }

  // Render a single group of tags.
  function renderGroup(type) {
    const groupEl = document.createElement('div');
    groupEl.className = 'group';
    // Create a header row with the type label and select/clear buttons
    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.justifyContent = 'space-between';
    header.style.alignItems = 'center';
    const title = document.createElement('h3');
    title.style.marginRight = '8px';
    // Use translated display name for the group if available
    const lang = document.getElementById('lang').value || languages[0];
    const nameMap = typeDisplay[type] || {};
    const label = nameMap[lang] || nameMap['en'] || type;
    title.textContent = label;
    // Buttons wrapper
    const btnWrap = document.createElement('div');
    btnWrap.style.display = 'flex';
    btnWrap.style.gap = '6px';
    const selAll = document.createElement('button');
    // Translate the "All" button label
    selAll.textContent = (uiStrings[lang] && uiStrings[lang].all) || 'All';
    selAll.addEventListener('click', () => {
      // Select all tags for this type
      state[type] = new Set((tagsByType[type] || []).map(item => item.tag));
      rerenderAll();
    });
    const clrAll = document.createElement('button');
    // Translate the "None" button label
    clrAll.textContent = (uiStrings[lang] && uiStrings[lang].none) || 'None';
    clrAll.addEventListener('click', () => {
      // Deselect all tags for this type
      state[type] = new Set();
      rerenderAll();
    });
    btnWrap.appendChild(selAll);
    btnWrap.appendChild(clrAll);
    header.appendChild(title);
    header.appendChild(btnWrap);
    groupEl.appendChild(header);
    // Determine language and items
    // Determine current language and list of tags once
    const currentLang = document.getElementById('lang').value || languages[0];
    const items = tagsByType[type] || [];
    if (!state[type]) state[type] = new Set();
    // Render all tags as checkboxes
    items.forEach(item => {
      const lab = document.createElement('label');
      lab.style.display = 'block';
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.value = item.tag;
      input.checked = state[type].has(item.tag);
      input.addEventListener('change', () => {
        // Update the state based on the checkbox and re-render the UI.  When
        // all items in a group are selected manually, re-rendering ensures
        // that the "all selected" warning appears without requiring the
        // dedicated "All" button.  rerenderAll() will also update the
        // feed URL via updateFeedUrl().
        if (input.checked) {
          state[type].add(item.tag);
        } else {
          state[type].delete(item.tag);
        }
        rerenderAll();
      });
      lab.appendChild(input);
      const span = document.createElement('span');
      span.textContent = ' ' + (item[`display_${currentLang}`] || item.tag);
      lab.appendChild(span);
      groupEl.appendChild(lab);
    });
    // If all tags for this group are selected, show a warning message
    if (state[type] && items.length > 0 && state[type].size === items.length) {
      const warn = document.createElement('div');
      warn.className = 'warning';
      const lang = document.getElementById('lang').value || languages[0];
      const strings = uiStrings[lang] || uiStrings.en;
      warn.textContent = strings.allSelectedWarning || 'All selected';
      groupEl.appendChild(warn);
    }
    document.getElementById('groups').appendChild(groupEl);
  }

  // Build query string from state and update the feedUrl input
  function updateFeedUrl() {
    const parts = [];
    for (const type of Object.keys(state)) {
      const values = Array.from(state[type]);
      if (values.length) {
        const encoded = values.map(v => encodeURIComponent(v)).join(',');
        parts.push(`${encodeURIComponent(type)}=${encoded}`);
      }
    }
    const query = parts.join('&');
    const url = parts.length ? `${BASE_URL}?${query}` : BASE_URL;
    document.getElementById('feedUrl').value = url;
    // Persist the current selections in sessionStorage so that when
    // users navigate away (e.g. to the instructions page) and come
    // back via the browser‚Äôs back button, their selections remain.
    try {
      const obj = {};
      for (const type in state) {
        obj[type] = Array.from(state[type]);
      }
      sessionStorage.setItem('feedState', JSON.stringify(obj));
    } catch (e) {
      // Fail silently if storage is unavailable
      console.warn('Could not save state to sessionStorage:', e);
    }
  }

  // Copy the current feed URL to the clipboard
  async function copyLinkToClipboard() {
    const el = document.getElementById('feedUrl');
    el.select();
    el.setSelectionRange(0, 99999);
    try {
      await navigator.clipboard.writeText(el.value);
    } catch (err) {
      // fallback: try to exec command
      document.execCommand('copy');
    }
    // Provide visual feedback when the copy succeeds.  Temporarily change
    // the button text to a success message and then restore the original
    // label after a short delay.  Use the translated strings for the
    // current language if available.
    const lang = document.getElementById('lang').value || 'en';
    const strings = uiStrings[lang] || uiStrings.en;
    const copyBtn = document.getElementById('copyLink');
    const originalText = strings.copyLink;
    // Set the success message
    copyBtn.textContent = strings.copySuccess || 'Copied!';
    // After 2 seconds, restore the original text
    setTimeout(() => {
      copyBtn.textContent = originalText;
    }, 2000);
  }

  // Clear all selections and rebuild UI
  function clearAllSelections() {
    for (const type in state) {
      state[type].clear();
    }
    rerenderAll();
    document.getElementById('feedUrl').value = BASE_URL;
  }

  // Restore previous selections from sessionStorage, if available.  This
  // function reads the stored JSON string (under the key
  // 'feedState') and updates the global state object accordingly.
  function loadStateFromStorage() {
    try {
      const raw = sessionStorage.getItem('feedState');
      if (!raw) return;
      const obj = JSON.parse(raw);
      for (const type in obj) {
        const arr = obj[type];
        if (Array.isArray(arr)) {
          // Ensure the state entry exists before populating
          state[type] = new Set(arr);
        }
      }
    } catch (err) {
      console.warn('Could not load state from sessionStorage:', err);
    }
  }

  // Attach control handlers
  document.getElementById('copyLink').addEventListener('click', copyLinkToClipboard);
  document.getElementById('clearAll').addEventListener('click', clearAllSelections);

  // Initialise everything on page load.  First fetch the tag UI
  // definitions and the per‚Äëtype tag CSVs from the resources
  // directory.  Once these are loaded we update languages, build the
  // language selector, update static text and render the groups.  If
  // any of these steps fail we still proceed with sensible defaults.
  (async () => {
    await loadTypeDisplay();
    await loadTagsData();
    // Restore previous selections before rendering the groups
    loadStateFromStorage();
    initLanguages();
    updateStaticText();
    rerenderAll();
  })();
  </script>
</body>
</html>