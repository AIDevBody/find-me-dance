<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Swing Calendar Feed Builder</title>
  <!--
    This page lets you compose a tag-based calendar feed for the Swing
    community. It mirrors the look and feel of the original Swing Tag
    Builder but instead of outputting a simple list of hashtags, it
    generates a ready‚Äëto‚Äëuse iCalendar (ICS) feed URL. The feed URL
    points at your deployed Google Apps Script (see the README or your
    deployment settings) and includes query parameters for every tag
    you select. Multiple selections within a single category are joined
    with commas. Subscribe to the resulting link in your favourite
    calendar client (Google Calendar, Apple Calendar, Outlook, etc.) to
    automatically receive events that match the selected tags.
  -->
  <style>
    :root {
      --gap: 12px;
      --pad: 14px;
      --radius: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    /* Constrain the width of the content on large screens */
    .container {
      max-width: 960px;
      margin-left: auto;
      margin-right: auto;
    }
    body {
      margin: 0;
      padding: 20px;
      background: #0b0f16;
      color: #eaf0ff;
    }
    body.modal-open {
      overflow: hidden;
    }
    a {
      color: #9bcbff;
    }
    header {
      margin-bottom: 22px;
    }
    .card {
      background: #121827;
      border: 1px solid #1f2a44;
      border-radius: var(--radius);
      padding: var(--pad);
      margin-bottom: var(--gap);
    }
    .alert {
      border: 1px solid #e5b867;
      border-radius: var(--radius);
      background: #2c210b;
      color: #ffe9b0;
      padding: 16px;
      margin-bottom: 16px;
    }
    .alert h2 {
      margin: 0 0 6px 0;
      font-size: 18px;
      color: #ffe9b0;
    }
    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: var(--gap);
    }
    .group {
      border: 1px solid #233455;
      border-radius: var(--radius);
      padding: var(--pad);
    }
    .group h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      font-weight: 600;
      color: #bcd1ff;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .controls button {
      width: 100%;
    }
    button,
    select {
      background: #1a2540;
      color: #eaf0ff;
      border: 1px solid #2a3f66;
      border-radius: 10px;
      padding: 8px 10px;
    }

    .hidden {
      display: none;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(7, 9, 15, 0.85);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 40px 20px;
      z-index: 2000;
    }
    .modal-content {
      background: #0f1628;
      border: 1px solid #2a3f66;
      border-radius: var(--radius);
      max-width: 520px;
      width: 100%;
      padding: 24px;
      position: relative;
    }
    .modal-content h2 {
      margin-top: 0;
      color: #ffd479;
    }
    .modal-close {
      position: absolute;
      top: 12px;
      right: 12px;
      background: transparent;
      border: none;
      color: #9fb3d9;
      font-size: 18px;
      cursor: pointer;
    }
    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 16px;
    }
    .modal-result {
      margin-top: 22px;
      padding-top: 16px;
      border-top: 1px solid #243251;
    }
    .modal-result label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #d0dbff;
    }
    .modal-copy-row {
      display: flex;
      justify-content: flex-end;
      margin-top: 8px;
    }
    .notice-checkbox {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      margin-top: 12px;
      line-height: 1.3;
    }
    .notice-checkbox input {
      margin-top: 2px;
    }

    /* Highlight the generate button */
    #generateLink {
      background: #3c548a;
      border-color: #4c6db5;
      color: #ffffff;
    }
    #generateLink:hover {
      background: #4c6db5;
    }
    input[type="text"] {
      width: 100%;
      background: #0e1527;
      color: #eaf0ff;
      border: 1px solid #2a3f66;
      border-radius: 10px;
      padding: 10px;
    }
    .muted {
      color: #9fb3d9;
    }
    .footer {
      margin-top: 20px;
      font-size: 12px;
    }
    details {
      margin-top: 8px;
    }
    summary {
      cursor: pointer;
    }

    /* Align the title and language selector on one line */
    .title-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: var(--gap);
    }
    /* Container for the language selector */
    .lang-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    /* Inline how-to text with button */
    .howto {
      margin-top: var(--gap);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }
    .howto a {
      background: #1a2540;
      color: #eaf0ff;
      border: 1px solid #2a3f66;
      border-radius: 10px;
      padding: 6px 10px;
      text-decoration: none;
    }
    /* Warning text inside groups when all options selected */
    .warning {
      font-size: 12px;
      color: #e5b867;
      margin-top: 6px;
    }
  </style>
</head>
<body>
  <div class="container">
    <section id="riskNotice" class="alert">
      <h2 id="riskTitle">Safety notice</h2>
      <p id="riskText">
        External links and descriptions shared by event organisers may lead away from find-me-dance. Open them only if you trust the sender ‚Äî we cannot take responsibility for their content.
      </p>
    </section>
    <header>
      <div class="title-bar">
        <!-- Title text will be localised via JavaScript -->
        <h1 id="title">üé∑ Swing Calendar Feed Builder</h1>
        <!-- Language selector moved into header for better positioning -->
        <div class="lang-container">
          <label id="langLabel"></label>
          <select id="lang"></select>
        </div>
      </div>
      <!-- Introductory paragraph will be localised via JavaScript -->
      <p id="intro" class="muted">
        Select the tags that describe your interests and we'll build a
        personalised calendar feed. Subscribe to the generated URL in
        your calendar client to stay up to date with events that match
        your selections.
      </p>
      <!-- Inline how‚Äëto text with link to the full instructions page. Visible at all times. -->
      <div id="howToInline" class="howto muted">
        <span id="howToText">Use ‚ÄúGenerate my calendar URL‚Äù to build your feed, then add it in your calendar app.</span>
        <!-- Do not open the instructions in a new window; users stay in the same tab -->
        <a id="howToButton" href="pages/instructions.html">Instructions</a>
      </div>
    </header>

    <section class="card">
      <div class="controls">
        <button id="clearAll" type="button">Clear all</button>
        <button id="generateLink" type="button">Generate my calendar URL</button>
      </div>
    </section>

    <section id="groups" class="row"></section>

    <div class="footer muted">
      <p>
        This page uses a locally stored list of tags to build the feed URL. It
        does not contact any external servers until you subscribe to the URL.
      </p>
    </div>
  </div> <!-- end container -->

  <div id="linkModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal-content">
      <button class="modal-close" id="modalClose" type="button" aria-label="Close dialog">√ó</button>
      <h2 id="modalTitle">Stay safe before you subscribe</h2>
      <p id="modalIntro">
        Event descriptions may contain external links. Treat every link with caution and only continue if you understand the risks.
      </p>
      <p id="modalReminder">
        Please re-read the warning at the top of this page. Your calendar provider cannot protect you from malicious third-party content.
      </p>
      <label class="notice-checkbox">
        <input type="checkbox" id="modalAcknowledge" />
        <span id="modalCheckboxLabel">I have read the warning and accept that opening links is at my own risk.</span>
      </label>
      <div class="modal-actions">
        <button id="modalCancel" type="button">Cancel</button>
        <button id="modalConfirm" type="button" disabled>Show my calendar URL</button>
      </div>
      <div id="modalResult" class="modal-result hidden">
        <p id="modalResultText">Copy this feed URL into the ‚Äúsubscribe to calendar‚Äù dialog of your favourite calendar app.</p>
        <label id="feedUrlLabel" for="feedUrl">Your calendar URL</label>
        <input id="feedUrl" type="text" readonly />
        <div class="modal-copy-row">
          <button id="copyLink" type="button">Copy calendar URL</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  // Base URL of your deployed Google Apps Script Web App (see user instructions)
  const BASE_URL = 'https://script.google.com/macros/s/AKfycbwLZ7yudmpkonocViR2Ai1TRiuW9Q0ho2DsNHABA88sUVXazLOg1rTrnFCNTcknCwjEtQ/exec';

  // Simple global error handler to log uncaught errors to the console.  This
  // remains quiet in the UI but aids debugging during development.
  window.addEventListener('error', (e) => {
    console.error('Uncaught error:', e.message);
  });

  // Localised UI strings for English and German.  These strings control
  // the visible text on the page (titles, buttons, labels, etc.).  If you
  // extend this page to support additional languages, add entries here.
  const uiStrings = {
    en: {
      title: 'üé∑ Swing Calendar Feed Builder',
      intro: 'Select the tags that describe your interests and we\'ll build a personalised calendar feed. Subscribe to the generated URL in your calendar client to stay up to date with events that match your selections.',
      language: 'Language:',
      copyLink: 'Copy calendar URL',
      generateLink: 'Generate my calendar URL',
      copySuccess: 'Copied!',
      clearAll: 'Clear all tags',
      riskTitle: 'Safety & responsibility reminder',
      riskBody: 'Event links and descriptions come directly from event managers and dance teachers. They must keep their listings clear, but misuse is always possible. We do not take responsibility for any third-party links‚Äîtreat every URL or request for information with caution before opening it from your calendar.',
      howToText: 'Use ‚ÄúGenerate my calendar URL‚Äù to create your feed, then paste it into your calendar application\'s ‚Äúsubscribe to calendar‚Äù or ‚Äúadd by URL‚Äù dialog. Most calendar clients support the iCalendar format.',
      inlineHowTo: 'Use ‚ÄúGenerate my calendar URL‚Äù to build your feed, then subscribe via your calendar app.',
      instructionsLabel: 'Instructions',
      footer: 'This page uses a locally stored list of tags to build the feed URL. It does not contact any external servers until you subscribe to the URL.',
      modalTitle: 'Stay safe before you subscribe',
      modalIntro: 'Event descriptions can include links that lead away from find-me-dance. Opening them is entirely at your own risk.',
      modalReminder: 'Re-read the warning at the top of this page and continue only if you understand the danger of malicious links and information requests.',
      modalCheckbox: 'I have read the warning and accept that opening links from event descriptions is my own responsibility.',
      modalCancel: 'Cancel',
      modalConfirm: 'Show my calendar URL',
      modalResultText: 'Copy this feed URL into the ‚Äúsubscribe to calendar‚Äù dialog of your preferred calendar app.',
      feedUrlLabel: 'Your calendar URL',
      all: 'All',
      none: 'None',
      allSelectedWarning: 'All tags selected: events without this type won‚Äôt appear. Select none to see all.'
    },
    de: {
      title: 'üé∑ Swing Kalender-Feed-Generator',
      intro: 'W√§hle die Tags aus, die deine Interessen beschreiben, und wir erstellen einen personalisierten Kalender-Feed. Abonniere die erzeugte URL in deiner Kalender-App, um √ºber passende Veranstaltungen auf dem Laufenden zu bleiben.',
      language: 'Sprache:',
      copyLink: 'Kalender‚ÄëURL kopieren',
      generateLink: 'Meinen Kalender-Link erzeugen',
      copySuccess: 'Kopiert!',
      clearAll: 'Alle Tags l√∂schen',
      riskTitle: 'Sicherheits- & Verantwortungshinweis',
      riskBody: 'Links und Beschreibungen stammen direkt von Veranstalter:innen und Trainer:innen. Sie sind verpflichtet, ihre Events klar zu halten, dennoch ist Missbrauch immer m√∂glich. Wir √ºbernehmen keine Verantwortung f√ºr externe Links ‚Äì pr√ºfe jede URL oder Informationsanfrage aus dem Kalender sehr sorgf√§ltig.',
      howToText: 'Nutze ‚ÄûMeinen Kalender-Link erzeugen‚Äú, um den Feed zu erstellen, und f√ºge ihn dann im Dialog ‚ÄûPer URL abonnieren‚Äú deiner Kalender-App ein. Die meisten Kalender unterst√ºtzen das iCalendar-Format.',
      inlineHowTo: 'Klicke auf ‚ÄûMeinen Kalender-Link erzeugen‚Äú, um den Feed zu bauen, und abonniere ihn dann in deiner Kalender-App.',
      instructionsLabel: 'Anleitung',
      footer: 'Diese Seite nutzt eine lokal gespeicherte Liste von Tags, um die Feed-URL zu erstellen. Es werden keine externen Server kontaktiert, bis du die URL abonnierst.',
      modalTitle: 'Bleib vorsichtig, bevor du abonnierst',
      modalIntro: 'Veranstaltungsbeschreibungen k√∂nnen Links enthalten, die find-me-dance verlassen. Das √ñffnen erfolgt auf dein eigenes Risiko.',
      modalReminder: 'Lies den Hinweis oben auf dieser Seite erneut und fahre nur fort, wenn du die Gefahr b√∂sartiger Links und Informationsabfragen verstanden hast.',
      modalCheckbox: 'Ich habe den Hinweis gelesen und akzeptiere, dass das √ñffnen von Links aus Event-Beschreibungen allein in meiner Verantwortung liegt.',
      modalCancel: 'Abbrechen',
      modalConfirm: 'Kalender-URL anzeigen',
      modalResultText: 'Kopiere diesen Feed in den Dialog ‚ÄûKalender per URL abonnieren‚Äú deiner Kalender-App.',
      feedUrlLabel: 'Deine Kalender-URL',
      all: 'Alle',
      none: 'Keine',
      allSelectedWarning: 'Alle ausgew√§hlt: Ereignisse ohne diese Kategorie werden nicht angezeigt. W√§hle keine aus, um alle zu sehen.'
    }
  };

  // Holds translated display names for each tag type (group labels).  This
  // mapping is populated asynchronously from tags/ui/tags_ui.csv on page load.
  let typeDisplay = {};

  // Fetch the tag UI CSV and build the typeDisplay map.  The CSV is expected
  // to have columns: tag_type, ui_type, display_en, display_de.  Any
  // additional languages can also be supported by adding more display_xx
  // columns.  Returns a promise that resolves when parsing is complete.
  async function loadTypeDisplay() {
    // Fetch the UI definitions for tag types.  This CSV lives under
    // resources/tags/ui/tags_ui.csv after we moved the tag folder into
    // the resources directory.  It contains columns: tag_type,
    // ui_type, display_en, display_de, etc.  We detect all
    // languages by looking for columns matching display_*.  The
    // resulting map is stored in the global typeDisplay object.
    try {
      // Fetch using a relative path from the resources directory.
      const res = await fetch('resources/tags/ui/tags_ui.csv', { cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to load tag UI definitions');
      const text = await res.text();
      const lines = text.trim().split(/\r?\n/);
      if (lines.length === 0) return;
      const header = lines[0].split(',');
      const idxType = header.indexOf('tag_type');
      const langCols = {};
      header.forEach((h, i) => {
        const m = h.match(/^display_(.+)$/);
        if (m) langCols[m[1]] = i;
      });
      const map = {};
      for (let i = 1; i < lines.length; i++) {
        const parts = lines[i].split(',');
        const type = parts[idxType];
        if (!type) continue;
        if (!map[type]) map[type] = {};
        for (const lang in langCols) {
          map[type][lang] = parts[langCols[lang]] || type;
        }
      }
      typeDisplay = map;
    } catch (err) {
      console.error(err);
      // fallback: leave typeDisplay empty if the file can't be loaded
    }
  }

  // Load all tag definitions from the CSV files under
  // resources/tags/all.  We determine which files to load based on the
  // tag types listed in the UI definitions (typeDisplay) or from the
  // names of files in that directory.  Each CSV must have columns
  // tag_type, tag, display_XX (for each language), and is-active
  // indicating whether the tag should be presented to the user.  Any
  // number of languages is supported: language codes are derived
  // automatically from the header names.  The resulting tags are
  // stored in the global tagsByType object keyed by tag_type.  The
  // global languages array is also updated to include all languages
  // encountered across the CSVs.
  async function loadTagsData() {
    // Determine candidate tag types from the UI definition.  If
    // typeDisplay is empty (for example if the UI CSV failed to load),
    // fall back to a hardcoded list of tag names that match the files
    // provided by the update_tags.sh script.
    const defaultTypes = [
      'location', 'dance_type', 'event_type', 'level', 'role',
      'music_speed', 'music_source', 'language', 'venue_type',
      'registration', 'price_type', 'age_policy', 'footwear'
    ];
    const types = Object.keys(typeDisplay);
    const toLoad = types.length > 0 ? types : defaultTypes;
    // Set to collect all languages discovered across all files
    const langSet = new Set(languages);
    // For each tag type, fetch and parse its CSV file
    for (const type of toLoad) {
      try {
        // Build the relative path to the CSV file.  Do not use absolute
        // file URLs as some environments may block them.
        const res = await fetch(`resources/tags/all/${type}.csv`, { cache: 'no-store' });
        if (!res.ok) {
          console.warn(`Could not load tags for type ${type}`);
          continue;
        }
        const csvText = await res.text();
        const lines = csvText.trim().split(/\r?\n/);
        if (lines.length === 0) continue;
        const header = lines[0].split(',');
        const idxTag = header.indexOf('tag');
        const idxActive = header.findIndex(h => h.toLowerCase() === 'is-active');
        // Detect language columns in the form display_xx
        const displayCols = {};
        header.forEach((h, i) => {
          const m = h.match(/^display_(.+)$/);
          if (m) {
            const code = m[1];
            displayCols[code] = i;
            langSet.add(code);
          }
        });
        // Prepare array of tag objects for this type
        const items = [];
        for (let i = 1; i < lines.length; i++) {
          // If there are extra commas inside quoted fields this split
          // might misbehave; but our spreadsheets produce simple CSVs.
          const parts = lines[i].split(',');
          const tagVal = parts[idxTag];
          // Skip rows without a tag value
          if (!tagVal) continue;
          // Only include active tags
          const isActive = idxActive >= 0 ? (parts[idxActive] || '').toLowerCase() === 'true' : true;
          if (!isActive) continue;
          const obj = { tag: tagVal };
          for (const code in displayCols) {
            obj[`display_${code}`] = parts[displayCols[code]] || tagVal;
          }
          items.push(obj);
        }
        // Store items for this type
        tagsByType[type] = items;
      } catch (err) {
        console.warn(`Error loading tag CSV for ${type}:`, err);
      }
    }
    // Update the global languages array based on the discovered set
    languages = Array.from(langSet);
  }

  // Update all static texts on the page based on the current language
  function updateStaticText() {
    const langSel = document.getElementById('lang');
    const lang = langSel.value || 'en';
    const strings = uiStrings[lang] || uiStrings.en;
    // Header title and intro
    const h1 = document.querySelector('header h1');
    if (h1) h1.textContent = strings.title;
    const introP = document.querySelector('header p');
    if (introP) introP.textContent = strings.intro;
    const riskTitle = document.getElementById('riskTitle');
    if (riskTitle) riskTitle.textContent = strings.riskTitle || 'Safety notice';
    const riskText = document.getElementById('riskText');
    if (riskText) riskText.textContent = strings.riskBody || '';
    // Language label in the header
    const langLabel = document.getElementById('langLabel');
    if (langLabel) {
      // Clear and rebuild the label text (select element remains separate)
      langLabel.textContent = strings.language + ' ';
    }
    // Buttons
    const copyBtn = document.getElementById('copyLink');
    if (copyBtn) copyBtn.textContent = strings.copyLink || 'Copy calendar URL';
    const clearBtn = document.getElementById('clearAll');
    if (clearBtn) clearBtn.textContent = strings.clearAll;
    const generateBtn = document.getElementById('generateLink');
    if (generateBtn) generateBtn.textContent = strings.generateLink || 'Generate my calendar URL';
    // Footer text
    const footerP = document.querySelector('.footer p');
    if (footerP) footerP.textContent = strings.footer;

    // Inline how-to text and instructions button
    const howToSpan = document.getElementById('howToText');
    if (howToSpan) howToSpan.textContent = strings.inlineHowTo;
    const howToBtn = document.getElementById('howToButton');
    if (howToBtn) howToBtn.textContent = strings.instructionsLabel;
    const modalTitle = document.getElementById('modalTitle');
    if (modalTitle) modalTitle.textContent = strings.modalTitle || '';
    const modalIntro = document.getElementById('modalIntro');
    if (modalIntro) modalIntro.textContent = strings.modalIntro || '';
    const modalReminder = document.getElementById('modalReminder');
    if (modalReminder) modalReminder.textContent = strings.modalReminder || '';
    const modalCheckbox = document.getElementById('modalCheckboxLabel');
    if (modalCheckbox) modalCheckbox.textContent = strings.modalCheckbox || '';
    const modalCancel = document.getElementById('modalCancel');
    if (modalCancel) modalCancel.textContent = strings.modalCancel || 'Cancel';
    const modalConfirm = document.getElementById('modalConfirm');
    if (modalConfirm) modalConfirm.textContent = strings.modalConfirm || 'Show my calendar URL';
    const modalResultText = document.getElementById('modalResultText');
    if (modalResultText) modalResultText.textContent = strings.modalResultText || '';
    const feedUrlLabel = document.getElementById('feedUrlLabel');
    if (feedUrlLabel) feedUrlLabel.textContent = strings.feedUrlLabel || 'Your calendar URL';
  }

  // Every category is rendered as a set of checkboxes. The original
  // Swing Tag Builder supported different UI widgets (dropdowns,
  // radios, etc.), but for simplicity and flexibility we ignore
  // those definitions here. This means visitors can select multiple
  // options per category. See renderGroup() for details.

  // Tags grouped by type will be populated by reading CSV files from
  // resources/tags/all on page load.  Each entry in this object
  // contains an array of tag definitions for that type.  See
  // loadTagsData() below for implementation.
  const tagsByType = {};

  // Note: We intentionally omit normalising UI types since every group
  // is rendered as a multi‚Äëselect checkbox list. See renderGroup().

  // State holds the currently selected tags for each type. Values are sets
  // to easily add/remove selections.
  const state = {};

  // List of available languages will be determined after loading the
  // tag CSVs.  Initialise with sensible defaults; loadTagsData()
  // updates this array once tags have been parsed.
  let languages = ['en', 'de'];

  // Populate the language selector and wire up change handler.  When the
  // selected language changes we update static text and re-render the groups.
  function initLanguages() {
    const sel = document.getElementById('lang');
    // Clear any existing options
    sel.innerHTML = '';
    languages.forEach(lang => {
      const opt = document.createElement('option');
      opt.value = lang;
      opt.textContent = lang;
      sel.appendChild(opt);
    });
    // Try to default to browser language if available
    const browserLang = (navigator.language || 'en').slice(0, 2);
    if (languages.includes(browserLang)) sel.value = browserLang;
    else if (languages.includes('en')) sel.value = 'en';
    sel.addEventListener('change', () => {
      updateStaticText();
      rerenderAll();
    });
  }

  // Build the UI groups based on tagsByType and ui definitions. This is
  // called whenever the language changes or the UI needs to be
  // refreshed. It clears any existing groups and reconstructs the
  // controls.
  function rerenderAll() {
    const container = document.getElementById('groups');
    container.innerHTML = '';
    for (const type of Object.keys(tagsByType).sort()) {
      renderGroup(type);
    }
    updateFeedUrl();
  }

  // Render a single group of tags.
  function renderGroup(type) {
    const groupEl = document.createElement('div');
    groupEl.className = 'group';
    // Create a header row with the type label and select/clear buttons
    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.justifyContent = 'space-between';
    header.style.alignItems = 'center';
    const title = document.createElement('h3');
    title.style.marginRight = '8px';
    // Use translated display name for the group if available
    const lang = document.getElementById('lang').value || languages[0];
    const nameMap = typeDisplay[type] || {};
    const label = nameMap[lang] || nameMap['en'] || type;
    title.textContent = label;
    // Buttons wrapper
    const btnWrap = document.createElement('div');
    btnWrap.style.display = 'flex';
    btnWrap.style.gap = '6px';
    const selAll = document.createElement('button');
    // Translate the "All" button label
    selAll.textContent = (uiStrings[lang] && uiStrings[lang].all) || 'All';
    selAll.addEventListener('click', () => {
      // Select all tags for this type
      state[type] = new Set((tagsByType[type] || []).map(item => item.tag));
      rerenderAll();
    });
    const clrAll = document.createElement('button');
    // Translate the "None" button label
    clrAll.textContent = (uiStrings[lang] && uiStrings[lang].none) || 'None';
    clrAll.addEventListener('click', () => {
      // Deselect all tags for this type
      state[type] = new Set();
      rerenderAll();
    });
    btnWrap.appendChild(selAll);
    btnWrap.appendChild(clrAll);
    header.appendChild(title);
    header.appendChild(btnWrap);
    groupEl.appendChild(header);
    // Determine language and items
    // Determine current language and list of tags once
    const currentLang = document.getElementById('lang').value || languages[0];
    const items = tagsByType[type] || [];
    if (!state[type]) state[type] = new Set();
    // Render all tags as checkboxes
    items.forEach(item => {
      const lab = document.createElement('label');
      lab.style.display = 'block';
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.value = item.tag;
      input.checked = state[type].has(item.tag);
      input.addEventListener('change', () => {
        // Update the state based on the checkbox and re-render the UI.  When
        // all items in a group are selected manually, re-rendering ensures
        // that the "all selected" warning appears without requiring the
        // dedicated "All" button.  rerenderAll() will also update the
        // feed URL via updateFeedUrl().
        if (input.checked) {
          state[type].add(item.tag);
        } else {
          state[type].delete(item.tag);
        }
        rerenderAll();
      });
      lab.appendChild(input);
      const span = document.createElement('span');
      span.textContent = ' ' + (item[`display_${currentLang}`] || item.tag);
      lab.appendChild(span);
      groupEl.appendChild(lab);
    });
    // If all tags for this group are selected, show a warning message
    if (state[type] && items.length > 0 && state[type].size === items.length) {
      const warn = document.createElement('div');
      warn.className = 'warning';
      const lang = document.getElementById('lang').value || languages[0];
      const strings = uiStrings[lang] || uiStrings.en;
      warn.textContent = strings.allSelectedWarning || 'All selected';
      groupEl.appendChild(warn);
    }
    document.getElementById('groups').appendChild(groupEl);
  }

  // Build query string from state and update the feedUrl input
  function updateFeedUrl() {
    const parts = [];
    for (const type of Object.keys(state)) {
      const values = Array.from(state[type]);
      if (values.length) {
        const encoded = values.map(v => encodeURIComponent(v)).join(',');
        parts.push(`${encodeURIComponent(type)}=${encoded}`);
      }
    }
    const query = parts.join('&');
    const url = parts.length ? `${BASE_URL}?${query}` : BASE_URL;
    document.getElementById('feedUrl').value = url;
    // Persist the current selections in sessionStorage so that when
    // users navigate away (e.g. to the instructions page) and come
    // back via the browser‚Äôs back button, their selections remain.
    try {
      const obj = {};
      for (const type in state) {
        obj[type] = Array.from(state[type]);
      }
      sessionStorage.setItem('feedState', JSON.stringify(obj));
    } catch (e) {
      // Fail silently if storage is unavailable
      console.warn('Could not save state to sessionStorage:', e);
    }
  }

  // Copy the current feed URL to the clipboard
  async function copyLinkToClipboard() {
    const el = document.getElementById('feedUrl');
    el.select();
    el.setSelectionRange(0, 99999);
    try {
      await navigator.clipboard.writeText(el.value);
    } catch (err) {
      // fallback: try to exec command
      document.execCommand('copy');
    }
    // Provide visual feedback when the copy succeeds.  Temporarily change
    // the button text to a success message and then restore the original
    // label after a short delay.  Use the translated strings for the
    // current language if available.
    const lang = document.getElementById('lang').value || 'en';
    const strings = uiStrings[lang] || uiStrings.en;
    const copyBtn = document.getElementById('copyLink');
    if (!copyBtn) return;
    const originalText = strings.copyLink || 'Copy calendar URL';
    // Set the success message
    copyBtn.textContent = strings.copySuccess || 'Copied!';
    // After 2 seconds, restore the original text
    setTimeout(() => {
      copyBtn.textContent = originalText;
    }, 2000);
  }

  function openLinkModal() {
    const modal = document.getElementById('linkModal');
    if (!modal) return;
    modal.classList.remove('hidden');
    document.body.classList.add('modal-open');
    const checkbox = document.getElementById('modalAcknowledge');
    if (checkbox) checkbox.checked = false;
    const confirmBtn = document.getElementById('modalConfirm');
    if (confirmBtn) confirmBtn.disabled = true;
    const result = document.getElementById('modalResult');
    if (result) result.classList.add('hidden');
    const lang = document.getElementById('lang').value || 'en';
    const strings = uiStrings[lang] || uiStrings.en;
    const copyBtn = document.getElementById('copyLink');
    if (copyBtn) copyBtn.textContent = strings.copyLink || 'Copy calendar URL';
  }

  function closeLinkModal() {
    const modal = document.getElementById('linkModal');
    if (!modal) return;
    modal.classList.add('hidden');
    document.body.classList.remove('modal-open');
  }

  // Clear all selections and rebuild UI
  function clearAllSelections() {
    for (const type in state) {
      state[type].clear();
    }
    rerenderAll();
    document.getElementById('feedUrl').value = BASE_URL;
  }

  // Restore previous selections from sessionStorage, if available.  This
  // function reads the stored JSON string (under the key
  // 'feedState') and updates the global state object accordingly.
  function loadStateFromStorage() {
    try {
      const raw = sessionStorage.getItem('feedState');
      if (!raw) return;
      const obj = JSON.parse(raw);
      for (const type in obj) {
        const arr = obj[type];
        if (Array.isArray(arr)) {
          // Ensure the state entry exists before populating
          state[type] = new Set(arr);
        }
      }
    } catch (err) {
      console.warn('Could not load state from sessionStorage:', err);
    }
  }

  // Attach control handlers
  document.getElementById('copyLink').addEventListener('click', copyLinkToClipboard);
  document.getElementById('clearAll').addEventListener('click', clearAllSelections);
  document.getElementById('generateLink').addEventListener('click', openLinkModal);
  document.getElementById('modalCancel').addEventListener('click', closeLinkModal);
  document.getElementById('modalClose').addEventListener('click', closeLinkModal);
  document.getElementById('linkModal').addEventListener('click', (event) => {
    if (event.target === event.currentTarget) closeLinkModal();
  });
  document.getElementById('modalAcknowledge').addEventListener('change', (event) => {
    document.getElementById('modalConfirm').disabled = !event.target.checked;
  });
  document.getElementById('modalConfirm').addEventListener('click', () => {
    const result = document.getElementById('modalResult');
    if (result) result.classList.remove('hidden');
    updateFeedUrl();
    const input = document.getElementById('feedUrl');
    if (input) {
      input.focus();
      input.select();
    }
  });
  window.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
      const modal = document.getElementById('linkModal');
      if (modal && !modal.classList.contains('hidden')) {
        closeLinkModal();
      }
    }
  });

  // Initialise everything on page load.  First fetch the tag UI
  // definitions and the per‚Äëtype tag CSVs from the resources
  // directory.  Once these are loaded we update languages, build the
  // language selector, update static text and render the groups.  If
  // any of these steps fail we still proceed with sensible defaults.
  (async () => {
    await loadTypeDisplay();
    await loadTagsData();
    // Restore previous selections before rendering the groups
    loadStateFromStorage();
    initLanguages();
    updateStaticText();
    rerenderAll();
  })();
  </script>
</body>
</html>
